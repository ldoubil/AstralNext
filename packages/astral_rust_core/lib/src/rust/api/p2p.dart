// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_instance_info`, `parse_instance_id`, `peer_conn_info_to_string`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MANAGER`, `RT`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `deref`, `deref`, `initialize`, `initialize`

Future<void> sendUdpToLocalhost({required String message}) =>
    RustLib.instance.api.crateApiP2PSendUdpToLocalhost(message: message);

Future<JoinHandle> handleEvent({required EventBusSubscriber events}) =>
    RustLib.instance.api.crateApiP2PHandleEvent(events: events);

Future<String> easytierVersion() =>
    RustLib.instance.api.crateApiP2PEasytierVersion();

Future<bool> isEasytierRunning({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PIsEasytierRunning(instanceId: instanceId);

Future<List<String>> getIps({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PGetIps(instanceId: instanceId);

Future<void> setTunFd({required String instanceId, required int fd}) =>
    RustLib.instance.api.crateApiP2PSetTunFd(instanceId: instanceId, fd: fd);

Future<String> getRunningInfo({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PGetRunningInfo(instanceId: instanceId);

Future<JoinHandleResultStringString> createServer({
  required String configToml,
  required bool watchEvent,
}) => RustLib.instance.api.crateApiP2PCreateServer(
  configToml: configToml,
  watchEvent: watchEvent,
);

Future<JoinHandleResultStringString> createServerWithFlags({
  required String username,
  required bool enableDhcp,
  required String specifiedIp,
  required String roomName,
  required String roomPassword,
  required List<String> severurl,
  required List<String> onurl,
  required List<String> cidrs,
  required List<Forward> forwards,
  required FlagsC flag,
}) => RustLib.instance.api.crateApiP2PCreateServerWithFlags(
  username: username,
  enableDhcp: enableDhcp,
  specifiedIp: specifiedIp,
  roomName: roomName,
  roomPassword: roomPassword,
  severurl: severurl,
  onurl: onurl,
  cidrs: cidrs,
  forwards: forwards,
  flag: flag,
);

Future<void> closeServer({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PCloseServer(instanceId: instanceId);

Future<List<PeerRoutePair>> getPeerRoutePairs({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PGetPeerRoutePairs(instanceId: instanceId);

Future<KVNetworkStatus> getNetworkStatus({required String instanceId}) =>
    RustLib.instance.api.crateApiP2PGetNetworkStatus(instanceId: instanceId);

Future<void> initApp() => RustLib.instance.api.crateApiP2PInitApp();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<EventBusSubscriber>>
abstract class EventBusSubscriber implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner< JoinHandle < () >>>
abstract class JoinHandle implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<JoinHandle < Result < String , String > >>>
abstract class JoinHandleResultStringString implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PeerRoutePair>>
abstract class PeerRoutePair implements RustOpaqueInterface {}

class FlagsC {
  final String defaultProtocol;
  final String devName;
  final bool enableEncryption;
  final bool enableIpv6;
  final int mtu;
  final bool latencyFirst;
  final bool enableExitNode;
  final bool noTun;
  final bool useSmoltcp;
  final String relayNetworkWhitelist;
  final bool disableP2P;
  final bool relayAllPeerRpc;
  final bool disableUdpHolePunching;
  final bool disableTcpHolePunching;
  final bool multiThread;
  final int dataCompressAlgo;
  final bool bindDevice;
  final bool enableKcpProxy;
  final bool disableKcpInput;
  final bool disableRelayKcp;
  final bool proxyForwardBySystem;
  final bool acceptDns;
  final bool privateMode;
  final bool enableQuicProxy;
  final bool disableQuicInput;
  final bool disableSymHolePunching;
  final String tcpWhitelist;
  final String udpWhitelist;

  const FlagsC({
    required this.defaultProtocol,
    required this.devName,
    required this.enableEncryption,
    required this.enableIpv6,
    required this.mtu,
    required this.latencyFirst,
    required this.enableExitNode,
    required this.noTun,
    required this.useSmoltcp,
    required this.relayNetworkWhitelist,
    required this.disableP2P,
    required this.relayAllPeerRpc,
    required this.disableUdpHolePunching,
    required this.disableTcpHolePunching,
    required this.multiThread,
    required this.dataCompressAlgo,
    required this.bindDevice,
    required this.enableKcpProxy,
    required this.disableKcpInput,
    required this.disableRelayKcp,
    required this.proxyForwardBySystem,
    required this.acceptDns,
    required this.privateMode,
    required this.enableQuicProxy,
    required this.disableQuicInput,
    required this.disableSymHolePunching,
    required this.tcpWhitelist,
    required this.udpWhitelist,
  });

  @override
  int get hashCode =>
      defaultProtocol.hashCode ^
      devName.hashCode ^
      enableEncryption.hashCode ^
      enableIpv6.hashCode ^
      mtu.hashCode ^
      latencyFirst.hashCode ^
      enableExitNode.hashCode ^
      noTun.hashCode ^
      useSmoltcp.hashCode ^
      relayNetworkWhitelist.hashCode ^
      disableP2P.hashCode ^
      relayAllPeerRpc.hashCode ^
      disableUdpHolePunching.hashCode ^
      disableTcpHolePunching.hashCode ^
      multiThread.hashCode ^
      dataCompressAlgo.hashCode ^
      bindDevice.hashCode ^
      enableKcpProxy.hashCode ^
      disableKcpInput.hashCode ^
      disableRelayKcp.hashCode ^
      proxyForwardBySystem.hashCode ^
      acceptDns.hashCode ^
      privateMode.hashCode ^
      enableQuicProxy.hashCode ^
      disableQuicInput.hashCode ^
      disableSymHolePunching.hashCode ^
      tcpWhitelist.hashCode ^
      udpWhitelist.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlagsC &&
          runtimeType == other.runtimeType &&
          defaultProtocol == other.defaultProtocol &&
          devName == other.devName &&
          enableEncryption == other.enableEncryption &&
          enableIpv6 == other.enableIpv6 &&
          mtu == other.mtu &&
          latencyFirst == other.latencyFirst &&
          enableExitNode == other.enableExitNode &&
          noTun == other.noTun &&
          useSmoltcp == other.useSmoltcp &&
          relayNetworkWhitelist == other.relayNetworkWhitelist &&
          disableP2P == other.disableP2P &&
          relayAllPeerRpc == other.relayAllPeerRpc &&
          disableUdpHolePunching == other.disableUdpHolePunching &&
          disableTcpHolePunching == other.disableTcpHolePunching &&
          multiThread == other.multiThread &&
          dataCompressAlgo == other.dataCompressAlgo &&
          bindDevice == other.bindDevice &&
          enableKcpProxy == other.enableKcpProxy &&
          disableKcpInput == other.disableKcpInput &&
          disableRelayKcp == other.disableRelayKcp &&
          proxyForwardBySystem == other.proxyForwardBySystem &&
          acceptDns == other.acceptDns &&
          privateMode == other.privateMode &&
          enableQuicProxy == other.enableQuicProxy &&
          disableQuicInput == other.disableQuicInput &&
          disableSymHolePunching == other.disableSymHolePunching &&
          tcpWhitelist == other.tcpWhitelist &&
          udpWhitelist == other.udpWhitelist;
}

class Forward {
  final String bindAddr;
  final String dstAddr;
  final String proto;

  const Forward({
    required this.bindAddr,
    required this.dstAddr,
    required this.proto,
  });

  @override
  int get hashCode => bindAddr.hashCode ^ dstAddr.hashCode ^ proto.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Forward &&
          runtimeType == other.runtimeType &&
          bindAddr == other.bindAddr &&
          dstAddr == other.dstAddr &&
          proto == other.proto;
}

class KVNetworkStatus {
  final BigInt totalNodes;
  final List<KVNodeInfo> nodes;

  const KVNetworkStatus({required this.totalNodes, required this.nodes});

  @override
  int get hashCode => totalNodes.hashCode ^ nodes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNetworkStatus &&
          runtimeType == other.runtimeType &&
          totalNodes == other.totalNodes &&
          nodes == other.nodes;
}

class KVNodeConnectionStats {
  final String connType;
  final BigInt rxBytes;
  final BigInt txBytes;
  final BigInt rxPackets;
  final BigInt txPackets;

  const KVNodeConnectionStats({
    required this.connType,
    required this.rxBytes,
    required this.txBytes,
    required this.rxPackets,
    required this.txPackets,
  });

  @override
  int get hashCode =>
      connType.hashCode ^
      rxBytes.hashCode ^
      txBytes.hashCode ^
      rxPackets.hashCode ^
      txPackets.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeConnectionStats &&
          runtimeType == other.runtimeType &&
          connType == other.connType &&
          rxBytes == other.rxBytes &&
          txBytes == other.txBytes &&
          rxPackets == other.rxPackets &&
          txPackets == other.txPackets;
}

class KVNodeInfo {
  final int peerId;
  final String hostname;
  final String ipv4;
  final double latencyMs;
  final String nat;
  final List<NodeHopStats> hops;
  final double lossRate;
  final List<KVNodeConnectionStats> connections;
  final String tunnelProto;
  final String connType;
  final BigInt rxBytes;
  final BigInt txBytes;
  final String version;
  final int cost;

  const KVNodeInfo({
    required this.peerId,
    required this.hostname,
    required this.ipv4,
    required this.latencyMs,
    required this.nat,
    required this.hops,
    required this.lossRate,
    required this.connections,
    required this.tunnelProto,
    required this.connType,
    required this.rxBytes,
    required this.txBytes,
    required this.version,
    required this.cost,
  });

  @override
  int get hashCode =>
      peerId.hashCode ^
      hostname.hashCode ^
      ipv4.hashCode ^
      latencyMs.hashCode ^
      nat.hashCode ^
      hops.hashCode ^
      lossRate.hashCode ^
      connections.hashCode ^
      tunnelProto.hashCode ^
      connType.hashCode ^
      rxBytes.hashCode ^
      txBytes.hashCode ^
      version.hashCode ^
      cost.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is KVNodeInfo &&
          runtimeType == other.runtimeType &&
          peerId == other.peerId &&
          hostname == other.hostname &&
          ipv4 == other.ipv4 &&
          latencyMs == other.latencyMs &&
          nat == other.nat &&
          hops == other.hops &&
          lossRate == other.lossRate &&
          connections == other.connections &&
          tunnelProto == other.tunnelProto &&
          connType == other.connType &&
          rxBytes == other.rxBytes &&
          txBytes == other.txBytes &&
          version == other.version &&
          cost == other.cost;
}

class NodeHopStats {
  final int peerId;
  final String targetIp;
  final double latencyMs;
  final double packetLoss;
  final String nodeName;

  const NodeHopStats({
    required this.peerId,
    required this.targetIp,
    required this.latencyMs,
    required this.packetLoss,
    required this.nodeName,
  });

  @override
  int get hashCode =>
      peerId.hashCode ^
      targetIp.hashCode ^
      latencyMs.hashCode ^
      packetLoss.hashCode ^
      nodeName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NodeHopStats &&
          runtimeType == other.runtimeType &&
          peerId == other.peerId &&
          targetIp == other.targetIp &&
          latencyMs == other.latencyMs &&
          packetLoss == other.packetLoss &&
          nodeName == other.nodeName;
}
